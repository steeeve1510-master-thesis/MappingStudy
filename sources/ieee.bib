@INPROCEEDINGS{7102617,
author={Felbinger, Hermann},
booktitle={2015 IEEE 8th International Conference on Software Testing, Verification and Validation (ICST)}, title={Test Suite Quality Assessment Using Model Inference Techniques},
year={2015},
volume={},
number={},
pages={1-2},
abstract={To state whether a System Under Test is sufficiently tested requires an assessment of the test suite quality. Existing methods to assess the quality of a test suite either are based on the structure of an implementation or determine the quality using mutation score. In this paper we introduce a method, which is based on inductive inference to assess the quality of a test suite and propose a method to augment a test suite depending on the quality assessment result. In this paper we provide a short glimpse on our objectives and show preliminary results of model inference of a test suite.},
keywords={Testing;Quality assessment;Computational modeling;Measurement;Software;Fault detection;Approximation methods},
doi={10.1109/ICST.2015.7102617},
ISSN={2159-4848},
month={April},}
@INPROCEEDINGS{7899053,
author={Felbinger, Hermann and Wotawa, Franz and Nica, Mihai},
booktitle={2017 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)}, title={Mutation Score, Coverage, Model Inference: Quality Assessment for T-Way Combinatorial Test-Suites},
year={2017},
volume={},
number={},
pages={171-180},
abstract={In this paper we assess and evaluate the quality of t-way combinatorial test-suites using three different test-suite quality assessment methods. As t-way combinatorial test-suites reduce the input space of a program under test, we investigate how an increasing t affects the quality of the test-suite. There are some limitations of existing test-suite quality assessment methods e.g. the number of mutants is limited by execution time and code coverage measurement might be intrusive due to changes of the behavior of the program under test when instrumenting the code. Here we generate t-way combinatorial test-suites for Java programs of different size. We compute mutation score and code coverage for the generated test-suites, and apply additionally a new model inference based approach, that does not require to execute the program under test, to compare the generated test-suites with each other and assign a quality valuation to the test-suites. Our results show that an increasing t generally raises test-suite quality in terms of mutation score, coverage, and model inference. However, the model inference approach is only applicable, if the outcomes of the programs under test are discrete values, and if the number of discrete values is less than the test-suite size.},
keywords={Testing;Quality assessment;Software;Instruments;Electronic mail;Computational modeling;Cost accounting;Mutation score;coverage;model inference;combinatorial testing},
doi={10.1109/ICSTW.2017.36},
ISSN={},
month={March},}
@INPROCEEDINGS{7810707,
author={Souza, Francisco Carlos M. and Papadakis, Mike and Le Traon, Yves and Delamaro, Márcio E.},
booktitle={2016 IEEE/ACM 9th International Workshop on Search-Based Software Testing (SBST)}, title={Strong Mutation-Based Test Data Generation Using Hill Climbing},
year={2016},
volume={},
number={},
pages={45-54},
abstract={Mutation Testing is an effective test criterion for finding faults and assessing the quality of a test suite. Every test criterion requires the generation of test cases, which turns to be a manual and difficult task. In literature, search-based techniques are effective in generating structural-based test data. This fact motivates their use for mutation testing. Thus, if automatic test data generation can achieve an acceptable level of mutation score, it has the potential to greatly reduce the involved manual effort. This paper proposes an automated test generation approach, using hill climbing, for strong mutation. It incremental aims at strongly killing mutants, by focusing on mutants' propagation, i.e., how to kill mutants that are weakly killed but not strongly. Furthermore, the paper reports empirical results regarding the cost and effectiveness of the proposed approach on a set of 18 C programs. Overall, for the majority of the studied programs, the proposed approach achieved a higher strong mutation score than random testing, by 19,02% on average, and the previously proposed test generation techniques that ignore mutants' propagation, by 7,2% on average. Our results also demonstrate the improved efficiency of the proposed scheme over the previous methods.},
keywords={Measurement;Manuals;Software testing;Computers;Security;Reliability;Mutation Testing;Search-Based Software Testing;Test Data Generation},
doi={10.1109/SBST.2016.018},
ISSN={},
month={May},}
@INPROCEEDINGS{7528953,
author={Lindström, Birgitta and Ḿrki, Andŕs},
booktitle={2016 IEEE Ninth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)}, title={On strong mutation and subsuming mutants},
year={2016},
volume={},
number={},
pages={112-121},
abstract={Mutation analysis is a powerful technique for software testing but it is also known to be computationally expensive. The main reason for the high computational cost is that many of the mutants are redundant and thus, do not contribute to the quality of the test suite. One of the most promising approaches to avoid producing redundant mutants is to identify subsumption relations among mutants, preferably before these are generated. Such relations have for example, been identified at an operator level for mutants created by the ROR operator. This reduced set of non-redundant mutants has been used in several recent studies and is also the default option in at least one mutation testing tool that supports strong mutation. This raises questions on whether the identified subsumption relations between the mutants hold in a context of strong mutation or variants of weak mutation that require some limited error propagation (firm mutation). We have conducted an experimental study to investigate the subsumption relations in the context of strong or firm mutation. We observed that it is possible to create a test suite that is 100% adequate for the reduced set of mutants while not being 100% adequate for the complete set. This shows that the subsumption relations do not hold for strong or firm mutation. We provide several examples on this behavior and discuss the root causes. Our findings are important since strong and firm mutation both are frequently used to evaluate test suites and testing criteria. The choice of whether to use a reduced set of mutants or an entire set should however, not be made without consideration of the context in which they are used (i.e., strong, firm or weak mutation) since the subsumption relations between ROR mutants do not hold for strong or firm mutation. Just as redundant mutants can give an overestimation of the mutation score for a test suite, using the reduced set of mutants can give an underestimation if used together with strong or firm mutation. Results reported from such studies should therefore, be accompanied by information on whether the reduced or complete set of mutants was used and if the researchers used strong, firm or weak mutation.},
keywords={Context;Software;Conferences;Software testing;Informatics;Computational efficiency;mutation testing;redundant mutant;strong mutation;subsumption},
doi={10.1109/ICSTW.2016.28},
ISSN={},
month={April},}
@INPROCEEDINGS{6958413,
author={Kracht, Jeshua S. and Petrovic, Jacob Z. and Walcott-Justice, Kristen R.},
booktitle={2014 14th International Conference on Quality Software}, title={Empirically Evaluating the Quality of Automatically Generated and Manually Written Test Suites},
year={2014},
volume={},
number={},
pages={256-265},
abstract={The creation, execution, and maintenance of tests are some of the most expensive tasks in software development. To help reduce the cost, automated test generation tools can be used to assist and guide developers in creating test cases. Yet, the tests that automated tools produce range from simple skeletons to fully executable test suites, hence their complexity and quality vary. This paper compares the complexity and quality of test suites created by sophisticated automated test generation tools to that of developer-written test suites. The empirical study in this paper examines ten real-world programs with existing test suites and applies two state-of-the-art automated test generation tools. The study measures the resulting test suite quality in terms of code coverage and fault-finding capability. On average, manual tests covered 31.5% of the branches while the automated tools covered 31.8% of the branches. In terms of mutation score, the tests generated by automated tools had an average mutation score of 39.8% compared to the average mutation score of 42.1% for manually written tests. Even though automatically created tests often contain more lines of source code than those written by developers, this paper's empirical results reveal that test generation tools can provide value by creating high quality test suites while reducing the cost and effort needed for testing.},
keywords={Manuals;Complexity theory;Software;Testing;Writing;Standards;Java},
doi={10.1109/QSIC.2014.33},
ISSN={2332-662X},
month={Oct},}
@INPROCEEDINGS{8170117,
author={Bach, Thomas and Andrzejak, Artur and Pannemans, Ralf and Lo, David},
booktitle={2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)}, title={The Impact of Coverage on Bug Density in a Large Industrial Software Project},
year={2017},
volume={},
number={},
pages={307-313},
abstract={Measuring quality of test suites is one of the major challenges of software testing. Code coverage identifies tested and untested parts of code and is frequently used to approximate test suite quality. Multiple previous studies have investigated the relationship between coverage ratio and test suite quality, without a clear consent in the results. In this work we study whether covered code contains a smaller number of future bugs than uncovered code (assuming appropriate scaling). If this correlation holds and bug density is lower in covered code, coverage can be regarded as a meaningful metric to estimate the adequacy of testing. To this end we analyse 16000 internal bug reports and bug-fixes of SAP HANA, a large industrial software project. We found that the above-mentioned relationship indeed holds, and is statistically significant. Contrary to most previous works our study uses real bugs and real bug-fixes. Furthermore, our data is derived from a complex and large industrial project.},
keywords={Computer bugs;Software;Tools;Software measurement;Software testing;Data collection;software quality;coverage;bug densitiy;large real world project;industry project;empirical research},
doi={10.1109/ESEM.2017.44},
ISSN={},
month={Nov},}
@INPROCEEDINGS{7927986,
author={Wang, Qianqian and Brun, Yuriy and Orso, Alessandro},
booktitle={2017 IEEE International Conference on Software Testing, Verification and Validation (ICST)}, title={Behavioral Execution Comparison: Are Tests Representative of Field Behavior?},
year={2017},
volume={},
number={},
pages={321-332},
abstract={Software testing is the most widely used approach for assessing and improving software quality, but it is inherently incomplete and may not be representative of how the software is used in the field. This paper addresses the questions of to what extent tests represent how real users use software, and how to measure behavioral differences between test and field executions. We study four real-world systems, one used by endusers and three used by other (client) software, and compare test suites written by the systems' developers to field executions using four models of behavior: statement coverage, method coverage, mutation score, and a temporal-invariant-based model we developed. We find that developer-written test suites fail to accurately represent field executions: the tests, on average, miss 6.2% of the statements and 7.7% of the methods exercised in the field, the behavior exercised only in the field kills an extra 8.6% of the mutants, finally, the tests miss 52.6% of the behavioral invariants that occur in the field. In addition, augmenting the in-house test suites with automatically-generated tests by a tool targeting high code coverage only marginally improves the tests' behavioral representativeness. These differences between field and test executions - and in particular the finer-grained and more sophisticated ones that we measured using our invariantbased model - can provide insight for developers and suggest a better method for measuring test suite quality.},
keywords={Testing;Computational modeling;Software measurement;Software quality;Tools;Libraries;software testing;field data;model inference},
doi={10.1109/ICST.2017.36},
ISSN={},
month={March},}
@INPROCEEDINGS{7589816,
author={Parsai, Ali and Murgia, Alessandro and Demeyer, Serge},
booktitle={2016 IEEE International Conference on Software Quality, Reliability and Security (QRS)}, title={A Model to Estimate First-Order Mutation Coverage from Higher-Order Mutation Coverage},
year={2016},
volume={},
number={},
pages={365-373},
abstract={The test suite is essential for fault detection during software development. First-order mutation coverage is an accurate metric to quantify the quality of the test suite. However, it is computationally expensive. Hence, the adoption of this metric is limited. In this study, we address this issue by proposing a realistic model able to estimate first-order mutation coverage using only higher-order mutation coverage. Our study shows how the estimation evolves along with the order of mutation. We validate the model with an empirical study based on 17 open-source projects.},
keywords={Testing;Computational modeling;Estimation;Mathematical model;Measurement;Open source software;Software Testing;Mutation Testing;Higher-order Mutation Testing;Test Suite Quality;Model},
doi={10.1109/QRS.2016.48},
ISSN={},
month={Aug},}
@ARTICLE{8240964,
author={McMinn, Phil and Wright, Chris J. and McCurdy, Colton J. and Kapfhammer, Gregory M.},
journal={IEEE Transactions on Software Engineering}, title={Automatic Detection and Removal of Ineffective Mutants for the Mutation Analysis of Relational Database Schemas},
year={2019},
volume={45},
number={5},
pages={427-463},
abstract={Data is one of an organization's most valuable and strategic assets. Testing the relational database schema, which protects the integrity of this data, is of paramount importance. Mutation analysis is a means of estimating the fault-finding “strength” of a test suite. As with program mutation, however, relational database schema mutation results in many “ineffective” mutants that both degrade test suite quality estimates and make mutation analysis more time consuming. This paper presents a taxonomy of ineffective mutants for relational database schemas, summarizing the root causes of ineffectiveness with a series of key patterns evident in database schemas. On the basis of these, we introduce algorithms that automatically detect and remove ineffective mutants. In an experimental study involving the mutation analysis of 34 schemas used with three popular relational database management systems-HyperSQL, PostgreSQL, and SQLite-the results show that our algorithms can identify and discard large numbers of ineffective mutants that can account for up to 24 percent of mutants, leading to a change in mutation score for 33 out of 34 schemas. The tests for seven schemas were found to achieve 100 percent scores, indicating that they were capable of detecting and killing all non-equivalent mutants. The results also reveal that the execution cost of mutation analysis may be significantly reduced, especially with “heavyweight” DBMSs like PostgreSQL.},
keywords={Relational databases;Algorithm design and analysis;Testing;Taxonomy;Google;Software;software testing;software quality;software tools;relational databases},
doi={10.1109/TSE.2017.2786286},
ISSN={1939-3520},
month={May},}
